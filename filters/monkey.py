#!/usr/bin/env python

# Author: Mort Yao <soi@mort.ninja>
# License:
#   This is free and unencumbered software released into the public domain.
"""
Monkeydown (or "Monkey Flavored Markdown") is a markdown extension,
designed in a way that monkeys can easily typeset Shakespeare's works.
Implemented as a JSON filter for monkey patching ASTs generated by pandoc,
it supports text conversion to HTML (or its derivatives).

For more details:
  http://www.soimort.org/filters/README.html
"""

from pandocfilters import *
import re, sys
def d(obj): print(obj, file=sys.stderr)



_fmt_supported = ['html', 'html5',
                  'slidy', 'slideous', 'dzslides', 'revealjs', 's5']

# Patterns of block commands
_cmd_patterns = {
    'h1'         : '^(h1)$',
    'h2'         : '^(h2)$',
    'h3'         : '^(h3)$',
    'h4'         : '^(h4)$',
    'h5'         : '^(h5)$',
    'h6'         : '^(h6)$',
    'left'       : '^(left|l|>)$',
    'left='      : '^(left|l|>)=(.+)$',
    'right'      : '^(right|r|<)$',
    'right='     : '^(right|r|<)=(.+)$',
    'center'     : '^(center|c|=)$',
    'width='     : '^(width|w)=(.+)$',
    'rtl'        : '^(rtl)$',
    'columns{'   : '^(columns|col)\[([^\]]*)\]\{?$',
    'columns}'   : '^\}?(columns|col)\}?$',
}

# Patterns of inline commands
_cmd_inline_patterns = {
    'linebreak'  : '^(linebreak|l)$',
    'linebreak=' : '^(linebreak|l)=(\d+)$',
    'nbsp'       : '^(nbsp|n)$',
    'nbsp='      : '^(nbsp|n)=(\d+)$',
    'underline'  : '^(underline|u)$',
    'color='     : '^(color)=(.+)$',
    'font='      : '^(font-family|font)=(.+)$',
    'font-size=' : '^(font-size)=(.+)$',
    'width='     : '^(width|w)=(.+)$',
    'kbd'        : '^(kbd)$',
    'samp'       : '^(samp)$',
    'var'        : '^(var)$',
}

# Alternative commands (shortcuts)
_cmd_alt = {
    # underline
    '_'          : {'underline'  : []},
    # linebreaks
    '|'          : {'linebreak'  : []},
    '||'         : {'linebreak=' : ['2']},
    '|||'        : {'linebreak=' : ['3']},
    '||||'       : {'linebreak=' : ['4']},
    '|||||'      : {'linebreak=' : ['5']},
    '||||||'     : {'linebreak=' : ['6']},
    '|||||||'    : {'linebreak=' : ['7']},
    '||||||||'   : {'linebreak=' : ['8']},
    # non-breaking spaces
    '-'          : {'nbsp=' : ['3']},
    '--'         : {'nbsp=' : ['7']},
    '---'        : {'nbsp=' : ['11']},
    '----'       : {'nbsp=' : ['15']},
    '-----'      : {'nbsp=' : ['19']},
    '------'     : {'nbsp=' : ['23']},
    '-------'    : {'nbsp=' : ['27']},
    '--------'   : {'nbsp=' : ['31']},
    # headers
    '#'          : {'h1' : []},
    '##'         : {'h2' : []},
    '###'        : {'h3' : []},
    '####'       : {'h4' : []},
    '#####'      : {'h5' : []},
    '######'     : {'h6' : []},
    # left-aligned headers
    '>#'         : {'left' : [], 'h1' : []},
    '>##'        : {'left' : [], 'h2' : []},
    '>###'       : {'left' : [], 'h3' : []},
    '>####'      : {'left' : [], 'h4' : []},
    '>#####'     : {'left' : [], 'h5' : []},
    '>######'    : {'left' : [], 'h6' : []},
    # right-aligned headers
    '<#'         : {'right' : [], 'h1' : []},
    '<##'        : {'right' : [], 'h2' : []},
    '<###'       : {'right' : [], 'h3' : []},
    '<####'      : {'right' : [], 'h4' : []},
    '<#####'     : {'right' : [], 'h5' : []},
    '<######'    : {'right' : [], 'h6' : []},
    # center-aligned headers
    '=#'         : {'center' : [], 'h1' : []},
    '=##'        : {'center' : [], 'h2' : []},
    '=###'       : {'center' : [], 'h3' : []},
    '=####'      : {'center' : [], 'h4' : []},
    '=#####'     : {'center' : [], 'h5' : []},
    '=######'    : {'center' : [], 'h6' : []},
    # left repositioning
    '>-'         : {'left=' : ['6.25%']},
    '>--'        : {'left=' : ['12.50%']},
    '>---'       : {'left=' : ['18.75%']},
    '>----'      : {'left=' : ['25.00%']},
    '>-----'     : {'left=' : ['31.25%']},
    '>------'    : {'left=' : ['37.50%']},
    '>-------'   : {'left=' : ['43.75%']},
    '>--------'  : {'left=' : ['50.00%']},
    # right repositioning
    '<-'         : {'right=' : ['6.25%']},
    '<--'        : {'right=' : ['12.50%']},
    '<---'       : {'right=' : ['18.75%']},
    '<----'      : {'right=' : ['25.00%']},
    '<-----'     : {'right=' : ['31.25%']},
    '<------'    : {'right=' : ['37.50%']},
    '<-------'   : {'right=' : ['43.75%']},
    '<--------'  : {'right=' : ['50.00%']},
}

# Patterns of inline extensions
_meta_interp_pattern = re.compile('(.*?)%\{([^\}]*)\}(.*)$') # non-greedy!
_ruby_pattern = re.compile('-(.*)$') # specified as Link target



# Block commands

def _h1(value: list, fmt: str, meta: dict) -> dict:
    """Header 1."""
    return Plain([RawInline(fmt, '<h1>')] + value + [RawInline(fmt, '</h1>')])

def _h2(value: list, fmt: str, meta: dict) -> dict:
    """Header 2."""
    return Plain([RawInline(fmt, '<h2>')] + value + [RawInline(fmt, '</h2>')])

def _h3(value: list, fmt: str, meta: dict) -> dict:
    """Header 3."""
    return Plain([RawInline(fmt, '<h3>')] + value + [RawInline(fmt, '</h3>')])

def _h4(value: list, fmt: str, meta: dict) -> dict:
    """Header 4."""
    return Plain([RawInline(fmt, '<h4>')] + value + [RawInline(fmt, '</h4>')])

def _h5(value: list, fmt: str, meta: dict) -> dict:
    """Header 5."""
    return Plain([RawInline(fmt, '<h5>')] + value + [RawInline(fmt, '</h5>')])

def _h6(value: list, fmt: str, meta: dict) -> dict:
    """Header 6."""
    return Plain([RawInline(fmt, '<h6>')] + value + [RawInline(fmt, '</h6>')])

def _left(value: list, fmt: str, meta: dict) -> dict:
    """Left-aligned paragraph."""
    return Plain([RawInline(fmt, '<p style="text-align:left !important;'
                            'text-indent:0 !important">')]
                 + value + [RawInline(fmt, '</p>')])

def _left_h1(value: list, fmt: str, meta: dict) -> dict:
    """Left-aligned header 1."""
    return Plain([RawInline(fmt, '<h1 style="text-align:left !important">')]
                 + value + [RawInline(fmt, '</h1>')])

def _left_h2(value: list, fmt: str, meta: dict) -> dict:
    """Left-aligned header 2."""
    return Plain([RawInline(fmt, '<h2 style="text-align:left !important">')]
                 + value + [RawInline(fmt, '</h2>')])

def _left_h3(value: list, fmt: str, meta: dict) -> dict:
    """Left-aligned header 3."""
    return Plain([RawInline(fmt, '<h3 style="text-align:left !important">')]
                 + value + [RawInline(fmt, '</h3>')])

def _left_h4(value: list, fmt: str, meta: dict) -> dict:
    """Left-aligned header 4."""
    return Plain([RawInline(fmt, '<h4 style="text-align:left !important">')]
                 + value + [RawInline(fmt, '</h4>')])

def _left_h5(value: list, fmt: str, meta: dict) -> dict:
    """Left-aligned header 5."""
    return Plain([RawInline(fmt, '<h5 style="text-align:left !important">')]
                 + value + [RawInline(fmt, '</h5>')])

def _left_h6(value: list, fmt: str, meta: dict) -> dict:
    """Left-aligned header 6."""
    return Plain([RawInline(fmt, '<h6 style="text-align:left !important">')]
                 + value + [RawInline(fmt, '</h6>')])

def _left_set(size: int, value: list, fmt: str, meta: dict) -> dict:
    """Left repositioning."""
    return Plain([RawInline(fmt, '<p style="text-align:left !important;'
                            'text-indent:0 !important;'
                            'position:relative;left:{0}">'.format(size))]
                 + value + [RawInline(fmt, '</p>')])

def _right(value: list, fmt: str, meta: dict) -> dict:
    """Right-aligned paragraph."""
    return Plain([RawInline(fmt, '<p style="text-align:right !important;'
                            'text-indent:0 !important">')]
                 + value + [RawInline(fmt, '</p>')])

def _right_h1(value: list, fmt: str, meta: dict) -> dict:
    """Right-aligned header 1."""
    return Plain([RawInline(fmt, '<h1 style="text-align:right !important">')]
                 + value + [RawInline(fmt, '</h1>')])

def _right_h2(value: list, fmt: str, meta: dict) -> dict:
    """Right-aligned header 2."""
    return Plain([RawInline(fmt, '<h2 style="text-align:right !important">')]
                 + value + [RawInline(fmt, '</h2>')])

def _right_h3(value: list, fmt: str, meta: dict) -> dict:
    """Right-aligned header 3."""
    return Plain([RawInline(fmt, '<h3 style="text-align:right !important">')]
                 + value + [RawInline(fmt, '</h3>')])

def _right_h4(value: list, fmt: str, meta: dict) -> dict:
    """Right-aligned header 4."""
    return Plain([RawInline(fmt, '<h4 style="text-align:right !important">')]
                 + value + [RawInline(fmt, '</h4>')])

def _right_h5(value: list, fmt: str, meta: dict) -> dict:
    """Right-aligned header 5."""
    return Plain([RawInline(fmt, '<h5 style="text-align:right !important">')]
                 + value + [RawInline(fmt, '</h5>')])

def _right_h6(value: list, fmt: str, meta: dict) -> dict:
    """Right-aligned header 6."""
    return Plain([RawInline(fmt, '<h6 style="text-align:right !important">')]
                 + value + [RawInline(fmt, '</h6>')])

def _right_set(size: int, value: list, fmt: str, meta: dict) -> dict:
    """Right repositioning."""
    return Plain([RawInline(fmt, '<p style="text-align:right !important;'
                            'text-indent:0 !important;'
                            'position:relative;right:{0}">'.format(size))]
                 + value + [RawInline(fmt, '</p>')])

def _center(value: list, fmt: str, meta: dict) -> dict:
    """Center-aligned paragraph."""
    return Plain([RawInline(fmt, '<p style="text-align:center !important;'
                            'text-indent:0 !important">')]
                 + value + [RawInline(fmt, '</p>')])

def _center_h1(value: list, fmt: str, meta: dict) -> dict:
    """Center-aligned header 1."""
    return Plain([RawInline(fmt, '<h1 style="text-align:center !important">')]
                 + value + [RawInline(fmt, '</h1>')])

def _center_h2(value: list, fmt: str, meta: dict) -> dict:
    """Center-aligned header 2."""
    return Plain([RawInline(fmt, '<h2 style="text-align:center !important">')]
                 + value + [RawInline(fmt, '</h2>')])

def _center_h3(value: list, fmt: str, meta: dict) -> dict:
    """Center-aligned header 3."""
    return Plain([RawInline(fmt, '<h3 style="text-align:center !important">')]
                 + value + [RawInline(fmt, '</h3>')])

def _center_h4(value: list, fmt: str, meta: dict) -> dict:
    """Center-aligned header 4."""
    return Plain([RawInline(fmt, '<h4 style="text-align:center !important">')]
                 + value + [RawInline(fmt, '</h4>')])

def _center_h5(value: list, fmt: str, meta: dict) -> dict:
    """Center-aligned header 5."""
    return Plain([RawInline(fmt, '<h5 style="text-align:center !important">')]
                 + value + [RawInline(fmt, '</h5>')])

def _center_h6(value: list, fmt: str, meta: dict) -> dict:
    """Center-aligned header 6."""
    return Plain([RawInline(fmt, '<h6 style="text-align:center !important">')]
                 + value + [RawInline(fmt, '</h6>')])

def _width_set(size: int, value: list, fmt: str, meta: dict) -> dict:
    """Width setting of paragraph."""
    return Plain([RawInline(fmt, '<p style="width:{0}">'.format(size))]
                 + value + [RawInline(fmt, '</p>')])

def _width_left_set(size: int, lsize: int, value: list, fmt: str, meta: dict) -> dict:
    """Width setting of paragraph with left repositioning."""
    return Plain([RawInline(fmt, '<p style="text-align:left !important;'
                            'text-indent:0 !important;'
                            'position:relative;width:{0};left:{1}">'.
                            format(size, lsize))]
                 + value + [RawInline(fmt, '</p>')])

def _rtl(value: list, fmt: str, meta: dict) -> dict:
    """Right-to-left text."""
    return Plain([RawInline(fmt, '<p dir="rtl">')]
                 + value + [RawInline(fmt, '</p>')])

def _columns_begin(param: str, fmt: str, meta: dict) -> dict:
    """Columns begin."""
    column_width, column_count = param.split(';')
    return Plain([RawInline(fmt, '<div style="columns:{0} {1};'
                            '-webkit-columns:{0} {1};-moz-columns:{0} {1}">'
                            .format(column_width, column_count))])

def _columns_end(fmt: str, meta: dict) -> dict:
    """Columns end."""
    return Plain([RawInline(fmt, '</div>')])

# Inline commands

def _linebreak(size: int, fmt: str, meta: dict) -> dict:
    """Hard linebreaks."""
    return [LineBreak()] * size

def _nbsp(size: int, fmt: str, meta: dict) -> dict:
    """Non-breaking spaces."""
    return RawInline(fmt, '&nbsp;' * size)

def _underline(value: list, fmt: str, meta: dict) -> dict:
    """Underlined text."""
    return [RawInline(fmt, "<u>")] + value + [RawInline(fmt, "</u>")]

def _span_set(color: str, font: str, font_size: str,
              value: list, fmt: str, meta: dict) -> dict:
    """Stylish text."""
    return Span(
        attributes({'style':
                    ('color:{0};'.format(color) if color else '') +
                    ('font-family:{0};'.format(font) if font else '') +
                    ('font-size:{0};'.format(font_size) if font_size else '')
                }), value)

def _kbd(value: list, fmt: str, meta: dict) -> dict:
    """Keyboard Input Element (<kbd>)."""
    return [RawInline(fmt, "<kbd>")] + value + [RawInline(fmt, "</kbd>")]

def _samp(value: list, fmt: str, meta: dict) -> dict:
    """Sample output from a computer program (<samp>)."""
    return [RawInline(fmt, "<samp>")] + value + [RawInline(fmt, "</samp>")]

def _var(value: list, fmt: str, meta: dict) -> dict:
    """Variable Element (<var>)."""
    return [RawInline(fmt, "<var>")] + value + [RawInline(fmt, "</var>")]

# Inline extensions

def _meta_interp(field: str, fmt: str, meta: dict, raw: bool = False) -> dict:
    """
    Allow interpolation of metadata fields into a document.
    %{fields} will be replaced by the field's value,
    assuming it is of the type MetaInlines or MetaString.
    """
    try:
        result = meta.get(field, {})
        if raw:
            return result['c']
        if result['t'] == 'MetaInlines':
            return Span(attributes({'class': 'interpolated',
                                    'field': field}),
                        result['c'])
        if result['t'] == 'MetaString':
            return Str(result['c'])
        raise Exception('[_meta_interp] Wrong type')
    except:
        #raise Exception('[_meta_interp] Failed to interpolate: ' + field)
        return RawInline(fmt, '') # return a null inline element

def _ruby(ruby: str, kanji: str, fmt: str, meta: dict) -> dict:
    """Ruby characters."""
    html = '<ruby>{0}<rp>(</rp><rt>{1}</rt><rp>)</rp></ruby>'.format(kanji, ruby)
    return RawInline(fmt, html)




def _to_str(a: list) -> str:
    """Convert a JSON array to string."""
    ret = ''
    for i in a:
        if i['t'] == 'Str':
            ret += i['c']
        elif i['t'] == 'Space':
            ret += ' '
    return ret

def mon(key: str, value: dict, fmt: str, meta: dict) -> dict:
    """Main filter."""

    if fmt not in _fmt_supported:
        raise Exception('Unsupported format: ' + fmt)
    fmt = 'html'

    try:
        if key == 'Para':
            # block commands
            t, c = value[0]['t'], value[0]['c']
            v = value[2:] # skip the next Space
            if t == 'Str' and c[0] == ':':
                cmd_strings = c[1:].split(',')
                cmd = {}
                for cmd_string in cmd_strings:
                    cmd_name, cmd_match = None, None
                    for name in _cmd_patterns:
                        cmd_pattern = _cmd_patterns[name]
                        cmd_match = re.match(cmd_pattern, cmd_string)
                        if cmd_match:
                            cmd_name = name
                            break
                    if cmd_match:
                        cmd[cmd_name] = list(cmd_match.groups()[1:])
                    elif cmd_string in _cmd_alt:
                        cmd.update(_cmd_alt[cmd_string])
                    else:
                        return # unknown block command

                # composite command processed first
                # left-aligned headers
                if 'left' in cmd and 'h1' in cmd:
                    return _left_h1(v, fmt, meta)
                if 'left' in cmd and 'h2' in cmd:
                    return _left_h2(v, fmt, meta)
                if 'left' in cmd and 'h3' in cmd:
                    return _left_h3(v, fmt, meta)
                if 'left' in cmd and 'h4' in cmd:
                    return _left_h4(v, fmt, meta)
                if 'left' in cmd and 'h5' in cmd:
                    return _left_h5(v, fmt, meta)
                if 'left' in cmd and 'h6' in cmd:
                    return _left_h6(v, fmt, meta)
                # right-aligned headers
                if 'right' in cmd and 'h1' in cmd:
                    return _right_h1(v, fmt, meta)
                if 'right' in cmd and 'h2' in cmd:
                    return _right_h2(v, fmt, meta)
                if 'right' in cmd and 'h3' in cmd:
                    return _right_h3(v, fmt, meta)
                if 'right' in cmd and 'h4' in cmd:
                    return _right_h4(v, fmt, meta)
                if 'right' in cmd and 'h5' in cmd:
                    return _right_h5(v, fmt, meta)
                if 'right' in cmd and 'h6' in cmd:
                    return _right_h6(v, fmt, meta)
                # center-aligned headers
                if 'center' in cmd and 'h1' in cmd:
                    return _center_h1(v, fmt, meta)
                if 'center' in cmd and 'h2' in cmd:
                    return _center_h2(v, fmt, meta)
                if 'center' in cmd and 'h3' in cmd:
                    return _center_h3(v, fmt, meta)
                if 'center' in cmd and 'h4' in cmd:
                    return _center_h4(v, fmt, meta)
                if 'center' in cmd and 'h5' in cmd:
                    return _center_h5(v, fmt, meta)
                if 'center' in cmd and 'h6' in cmd:
                    return _center_h6(v, fmt, meta)
                # misc
                if 'width=' in cmd and 'left=' in cmd:
                    return _width_left_set(cmd['width='][0], cmd['left='][0],
                                           v, fmt, meta)

                # single command
                if 'h1' in cmd:
                    return _h1(v, fmt, meta)
                if 'h2' in cmd:
                    return _h2(v, fmt, meta)
                if 'h3' in cmd:
                    return _h3(v, fmt, meta)
                if 'h4' in cmd:
                    return _h4(v, fmt, meta)
                if 'h5' in cmd:
                    return _h5(v, fmt, meta)
                if 'h6' in cmd:
                    return _h6(v, fmt, meta)
                if 'left' in cmd:
                    return _left(v, fmt, meta)
                if 'left=' in cmd:
                    return _left_set(cmd['left='][0], v, fmt, meta)
                if 'right' in cmd:
                    return _right(v, fmt, meta)
                if 'right=' in cmd:
                    return _right_set(cmd['right='][0], v, fmt, meta)
                if 'center' in cmd:
                    return _center(v, fmt, meta)
                if 'width=' in cmd:
                    return _width_set(cmd['width='][0], v, fmt, meta)
                if 'rtl' in cmd:
                    return _rtl(v, fmt, meta)
                if 'columns{' in cmd:
                    return _columns_begin(cmd['columns{'][0], fmt, meta)
                if 'columns}' in cmd:
                    return _columns_end(fmt, meta)

                return
            return # not a command

        if key == 'BulletList':
            # FIXME: formatting not handled where checkbox appears
            ret = []
            for item in value:
                c0 = item[0]['c']
                if len(c0) > 2 and c0[0]['c'] == '[' and c0[1]['t'] == 'Space' and c0[2]['c'] == ']':
                    ret.append([{'t': item[0]['t'],
                                 'c': [RawInline(fmt, '<input type="checkbox">')] +
                                 c0[3:]}] + item[1:])
                elif len(c0) > 0 and c0[0]['c'] == '[x]':
                    ret.append([{'t': item[0]['t'],
                                 'c': [RawInline(fmt, '<input type="checkbox" checked>')] +
                                 c0[1:]}] + item[1:])
                else:
                    ret.append(item)

            return BulletList(ret)

        if key == 'Str':
            # metadata interpolation
            meta_interp_match = _meta_interp_pattern.match(value)
            if meta_interp_match:
                # FIXME!!!!
                return _meta_interp(meta_interp_match.group(2), fmt, meta)

            # inline commands
            if value[0] == ':':
                cmd_strings = value[1:].split(',')
                cmd = {}
                for cmd_string in cmd_strings:
                    cmd_name, cmd_match = None, None
                    for name in _cmd_inline_patterns:
                        cmd_pattern = _cmd_inline_patterns[name]
                        cmd_match = re.match(cmd_pattern, cmd_string)
                        if cmd_match:
                            cmd_name = name
                            break
                    if cmd_match:
                        cmd[cmd_name] = list(cmd_match.groups()[1:])
                    elif cmd_string in _cmd_alt:
                        cmd.update(_cmd_alt[cmd_string])
                    else:
                        return # unknown inline command

                if 'nbsp' in cmd:
                    return _nbsp(1, fmt, meta)
                if 'nbsp=' in cmd:
                    return _nbsp(int(cmd['nbsp='][0]), fmt, meta)
                if 'linebreak' in cmd:
                    return _linebreak(1, fmt, meta)
                if 'linebreak=' in cmd:
                    return _linebreak(int(cmd['linebreak='][0]), fmt, meta)

                return Str(value)
            return # not a command

        if key == 'Link':
            inlines, target = value
            url, title = target

            # metadata interpolation
            # process: [Inline]
            new_inlines = []
            for inline in inlines:
                if inline['t'] == 'Str':
                    inline_match = _meta_interp_pattern.match(inline['c'])
                    if inline_match:
                        # need the whole object
                        new_inlines += _meta_interp(inline_match.group(2), fmt, meta, True)
                        # FIXME!!!!
                    else:
                        new_inlines += [inline]
                else:
                    new_inlines += [inline]
            inlines = new_inlines
            # process: Target
            url, title = target
            url, orig = '', url
            match = _meta_interp_pattern.match(orig)
            while match:
                url += match.group(1)
                metavar = _meta_interp(match.group(2), fmt, meta, True)
                url += metavar if isinstance(metavar, str) else _to_str(metavar)
                orig = match.group(3)
                match = _meta_interp_pattern.match(orig)
            url += orig
            title, orig = '', title
            match = _meta_interp_pattern.match(orig)
            while match:
                title += match.group(1)
                metavar = _meta_interp(match.group(2), fmt, meta, True)
                title += metavar if isinstance(metavar, str) else _to_str(metavar)
                orig = match.group(3)
                match = _meta_interp_pattern.match(orig)
            title += orig
            # default return value
            ret = Link(inlines, [url, title])

            # ruby
            ruby_match = _ruby_pattern.match(url)
            if ruby_match:
                # [Inline] must be a single Str
                if len(inlines) == 1 and inlines[0]['t'] == 'Str':
                    return _ruby(inlines[0]['c'], ruby_match.group(1), fmt, meta)

            # inline commands
            v = inlines
            if url[0] == ':':
                cmd_strings = url[1:].split(',')
                cmd = {}
                for cmd_string in cmd_strings:
                    cmd_name, cmd_match = None, None
                    for name in _cmd_inline_patterns:
                        cmd_pattern = _cmd_inline_patterns[name]
                        cmd_match = re.match(cmd_pattern, cmd_string)
                        if cmd_match:
                            cmd_name = name
                            break
                    if cmd_match:
                        cmd[cmd_name] = list(cmd_match.groups()[1:])
                    elif cmd_string in _cmd_alt:
                        cmd.update(_cmd_alt[cmd_string])
                    else:
                        return # unknown inline command

                if 'kbd' in cmd:
                    return _kbd(v, fmt, meta)
                if 'samp' in cmd:
                    return _samp(v, fmt, meta)
                if 'var' in cmd:
                    return _var(v, fmt, meta)

                return ret
            return ret # not a command

        if key == "Strikeout":
            # inline commands
            t, c = value[0]['t'], value[0]['c']
            v = value[2:] # skip the next Space
            if t == 'Str' and c[0] == ':':
                cmd_strings = c[1:].split(',')
                cmd = {}
                for cmd_string in cmd_strings:
                    cmd_name, cmd_match = None, None
                    for name in _cmd_inline_patterns:
                        cmd_pattern = _cmd_inline_patterns[name]
                        cmd_match = re.match(cmd_pattern, cmd_string)
                        if cmd_match:
                            cmd_name = name
                            break
                    if cmd_match:
                        cmd[cmd_name] = list(cmd_match.groups()[1:])
                    elif cmd_string in _cmd_alt:
                        cmd.update(_cmd_alt[cmd_string])
                    else:
                        return # unknown inline command

                color = cmd['color='][0] if 'color=' in cmd else None
                font = cmd['font='][0] if 'font=' in cmd else None
                font_size = cmd['font-size='][0] if 'font-size=' in cmd else None

                if 'underline' in cmd:
                    return _underline(v, fmt, meta)
                if 'color=' in cmd or 'font=' in cmd or 'font-size=' in cmd:
                    return _span_set(color, font, font_size, v, fmt, meta)

                return Strikeout(value)
            return # not a command

        if key == 'Image':
            # inline commands
            t, c = value[0][0]['t'], value[0][0]['c']
            if t == 'Str' and c[0] == ':':
                cmd_strings = c[1:].split(',')
                cmd = {}
                for cmd_string in cmd_strings:
                    cmd_name, cmd_match = None, None
                    for name in _cmd_inline_patterns:
                        cmd_pattern = _cmd_inline_patterns[name]
                        cmd_match = re.match(cmd_pattern, cmd_string)
                        if cmd_match:
                            cmd_name = name
                            break
                    if cmd_match:
                        cmd[cmd_name] = list(cmd_match.groups()[1:])
                    elif cmd_string in _cmd_alt:
                        cmd.update(_cmd_alt[cmd_string])
                    else:
                        return # unknown inline command

                # FIXME: not properly implemented
                # FIXME: html5 uses <figure></figure>
                inline_str = _to_str(value[0][2:])
                if 'width=' in cmd:
                    src, fig = value[1][0], value[1][1][4:]
                    return RawInline(fmt, '<div class="figure">'
                                     '<img src="{0}" title="{1}" alt="{2}" width="{3}" />'
                                     '<p class="caption">{2}</p>'
                                     '</div>'.format(src, fig, inline_str, cmd['width='][0]))

                return
            return # not a command

        return # TODO
    except:
        raise Exception('Malformed AST in: ' + key)

if __name__ == "__main__":
    toJSONFilter(mon)
