<!DOCTYPE html>
<!-- Akai (pandoc HTML5 template)
     designer:     soimort
     last updated: 2016-05-06
     last adapted: 2016-11-01 -->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <meta name="author" content="Mort Yao">
    <meta name="dcterms.date" content="2016-11-15">
    <title>Bloom Filters in Adversarial Environments</title>
    <link rel="canonical" href="https://www.soimort.org/reports/bloom-filters-in-adversarial-environments">
    <style type="text/css">code { white-space: pre; }</style>
    <link rel="stylesheet" href="//cdn.soimort.org/normalize/5.0.0/normalize.min.css">
    <link rel="stylesheet" href="//cdn.soimort.org/fonts/api/URW-Palladio-L.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/__/css/style.css">
    <link rel="stylesheet" href="/__/css/pygments.css">
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
    <![endif]-->
    <script src="//cdn.soimort.org/jk/latest/jk.min.js"></script>
    <link rel="icon" href="/favicon.png">
    <link rel="apple-touch-icon" href="/favicon.png">
    <link rel="alternate" type="application/atom+xml" href="/feed.atom">
  </head>
  <body>
    <article>
      <header>
        <h1 class="title"><a href="https://www.soimort.org/reports/bloom-filters-in-adversarial-environments">Bloom Filters in Adversarial Environments</a></h1>
        <h1 class="subtitle"><a href="https://www.soimort.org/reports/bloom-filters-in-adversarial-environments">Reading report</a></h1>
        <address class="author">Mort Yao</address>
        <h3 class="date">2016-11-15</h3>
      </header>
      <div id="content">
<p><p style='background-color:yellow'> This is an expository reading summary of a selected <a href="https://eprint.iacr.org/2015/543.pdf">CRYPTO 2015 paper</a> I did as an assignment in KU’s <a href="http://kurser.ku.dk/course/nscphd1080/2016-2017">Introduction to Modern Cryptography</a> course. Adversarial-resilient Bloom filters are the counterparts of cryptographically secure hash functions in an adversarial setting, where adaptive adversaries that have access to a deterministic or non-deterministic query oracle may challenge the data structure in a way that intentionally increases the false positive rate of querying. As a preliminary result, this paper shows that the resistance of Bloom filters against computationally bounded adversaries requires that <a href="/mst/1/#p-versus-np-problem-and-one-way-functions">one-way functions exist</a>; furthermore, such constructions are possible using pseudorandom permutations. I do find the proof a bit involved, but the notions of security introduced for Bloom filters are new and appealing (which I haven’t read previously anywhere else).<br />
There is also a <a href="https://www.dropbox.com/s/qgo4uat7zghu8vz/notes.pdf?dl=1">PDF version</a> of this report.</p></p>
<p>Original paper:</p>
<ul>
<li><strong>M. Naor and E. Yogev, “Bloom filters in adversarial environments,” in Annual Cryptology Conference, 2015.</strong> <a href="https://arxiv.org/abs/1412.8356">[arXiv:1412.8356]</a></li>
</ul>
<hr />
<p style="text-align:center !important;text-indent:0 !important"><strong>Abstract</strong></p>
<p>Bloom filter is a hash-based probabilistic data structure which is space-efficient for set membership querying, with a small probability of false positives. Naor and Yogev’s 2015 paper introduces the adversarial model and formally proposes a strong notion of security for Bloom filters, i.e., <em>adversarial resilience</em>, based on an adversarial game under a cryptographic setting. This paper also discusses the correspondence between adversarial-resilient Bloom filters and the open assumption that one-way functions exist, thus enables theoretical constructions using pseudorandom permutations. We believe that such an understanding will help design practical Bloom filters that are safe from known attacks in software systems.</p>
<section id="introduction" class="level1">
<h1>1. Introduction</h1>
<p>Probabilistic data structures are data structures that employ randomness in their designs to enable more efficient approaches of storing and querying data, compared to deterministic ones. Traditionally, the algorithmic probabilistic analysis of such data structures assumes the model where all inputs and queries are <em>independent</em> of the internal randomness of data structures. In this work, we consider an adversarial environment, where a computationally bounded adversary<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> may adaptively chooses inputs and queries with the intention of degrading the efficiency of the underlying data structure of some computer system. By introducing the adversarial model, we analyze the behavior of such data representations under the cryptographic notion of computational security against adversaries; furthermore, it enables us to construct more efficient, provably secure schemes of probabilistic data structures.</p>
<p>As a concrete example, a Bloom filter is a probabilistic data structure that holds a set <span class="math inline">\(S\)</span> of elements approximately, using significantly fewer bits of storage and allowing for faster access than a complete representation. As a trade-off between efficiency and preciseness, for any query of <span class="math inline">\(x \in S\)</span>, a Bloom filter always outputs a <em>yes</em>-answer, and for any query of <span class="math inline">\(x \not\in S\)</span>, it should output a <em>yes</em>-answer only with small probability. In other words, a <em>no</em>-answer given by a Bloom filter indicates unambiguously that <span class="math inline">\(x \not\in S\)</span>, while a <em>yes</em>-answer indicates that <span class="math inline">\(x \in S\)</span> probably holds<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>, that is, it allows false positives. Ideally, the error probability that a Bloom filter returns a false positive should be as small as possible.</p>
<p>Approaching the commonly-seen set membership problem, Bloom filters have been implemented widely in real-world applications, specifically as internal data representations for optimizing large-scale software systems. For example, Akamai’s CDN<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> servers maintain Bloom filters in their memories to decide whether to lookup the disk cache for a requested resource, and a false positive of the Bloom filter causes a cache miss, which means that the server has to make an unnecessary disk lookup at an expense of time and system workload; if an attacker exploits the behaviors of the Bloom filter, it is possible for them to cast queries that degrade the disk cache hit rate of the CDN servers, and consequently, perform a Denial-of-Service (DoS) attack.<span class="citation" data-cites="maggs2015algorithmic">[1]</span> On another scenario, where Bitcoin clients apply Bloom filters in the Simplified Payment Verification (SPV) mode to increase the overall performance of wallet synchronization, an adversary may perform a DoS attack on an SPV node by learning from the responses of Bloom filters they have access to.<span class="citation" data-cites="benjaminattacks">[2]</span></p>
<p>As discussed above, the adversarial model addresses some security issues, thus the necessity of defining security in adversarial environments and constructing provably secure Bloom filters arises. Essentially, it is desirable for a well-constructed Bloom filter to maintain its small error probability in an adversarial environment; we say that such a Bloom filter is <em>adversarial resilient</em> (or just <em>resilient</em>). In an adversarial game, where an adversary has oracle access to the Bloom filter and is allowed to make a number of <span class="math inline">\(t\)</span> queries before it outputs a certain <span class="math inline">\(x^*\)</span> (that has not been queried before) which is believed to be a false positive, and if it is, the adversary wins the game. We say that a Bloom filter is <span class="math inline">\((n,t,\varepsilon)\)</span>-<em>adversarial resilient</em> if when initialized over sets of size <span class="math inline">\(n\)</span> then after <span class="math inline">\(t\)</span> queries the probability of <span class="math inline">\(x^*\)</span> being a false positive is at most <span class="math inline">\(\varepsilon\)</span>. A Bloom filter that is resilient for any polynomially many queries is said to be <em>strongly resilient</em>.</p>
<p>Clearly, a trivial construction of a strongly resilient Bloom filter would be a deterministic lookup table that stores <span class="math inline">\(S\)</span> precisely, so that there is no false positive which an adversary can find. However, such a construction does not take advantage of the space and time efficiency as a normal Bloom filter would do, since it stores every element in the memory. In the following, we consider only non-trivial Bloom filters, and we show that for a non-trivial Bloom filter to be adversarial-resilient, one-way functions must exist; that is, if one-way functions do not exist, then any non-trivial Bloom filter can be attacked with a non-negligible probability by an efficient adversary. Furthermore, under the assumption that one-way functions exist, a pseudorandom permutation (PRP) can be used to construct a strongly resilient Bloom filter which has a reasonable memory consumption.</p>
<p>The construction of a Bloom filter consists of two algorithms: an initialization algorithm that gets a set <span class="math inline">\(S\)</span> and outputs a memory-efficient representation of <span class="math inline">\(S\)</span>; a query algorithm that gets a representation of <span class="math inline">\(S\)</span> and an <span class="math inline">\(x\)</span> to be checked and outputs <span class="math inline">\(1\)</span> if <span class="math inline">\(x \in S\)</span>, otherwise <span class="math inline">\(0\)</span>. Typically, the initialization algorithm is randomized but the query algorithm is deterministic, that is, a query operation does not amend the existing representation. We say that such a Bloom filter has a <em>steady representation</em>.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
</section>
<section id="definitions" class="level1">
<h1>2. Definitions</h1>
<p>In the following model, we consider a universal set <span class="math inline">\(U\)</span> and a subset <span class="math inline">\(S \subset U\)</span> to be stored in a Bloom filter. We denote that <span class="math inline">\(u=|U|\)</span> and <span class="math inline">\(n=|S|\)</span>.</p>
<p><strong>Definition 1. (Steady-representation Bloom filter)</strong> <em>Let <span class="math inline">\(\mathbf{B}=(\mathbf{B}_1,\mathbf{B}_2)\)</span> be a pair of polynomial-time algorithms, where <span class="math inline">\(\mathbf{B}_1\)</span> is a randomized algorithm that gets as input a set <span class="math inline">\(S\)</span> and outputs a representation <span class="math inline">\(M\)</span>, and <span class="math inline">\(\mathbf{B}_2\)</span> is a deterministic algorithm that gets as input a representation <span class="math inline">\(M\)</span> and a query element <span class="math inline">\(x \in U\)</span>. We say that <span class="math inline">\(\mathbf{B}\)</span> is an <span class="math inline">\((n,\varepsilon)\)</span>-Bloom filter (with a steady representation) if for any set <span class="math inline">\(S \subset U\)</span> of size <span class="math inline">\(n\)</span> it holds that:</em></p>
<ol type="1">
<li><p><span class="math inline">\(\forall x \in S, \Pr[\mathbf{B}_2(\mathbf{B}_1(S), x) = 1] = 1\)</span> <strong>(Completeness)</strong></p></li>
<li><p><span class="math inline">\(\forall x \not\in S, \Pr[\mathbf{B}_2(\mathbf{B}_1(S), x) = 1] \leq \varepsilon\)</span> <strong>(Soundness)</strong></p></li>
</ol>
<p><em>where the probability is taken over the randomness used by the algorithm <span class="math inline">\(\mathbf{B}_1\)</span>.</em></p>
<p>Intuitively, the first property (completeness) says that for all elements in the set <span class="math inline">\(S\)</span>, the Bloom filter is guaranteed to output a <em>yes</em>-answer correctly; the second property (soundness) gives the upper bound that the Bloom filter outputs a false positive, that is, the query algorithm returns <span class="math inline">\(1\)</span> when an element does not actually belong to the set <span class="math inline">\(S\)</span>. Formally,</p>
<p><strong>False positive and error rate.</strong> Given a representation <span class="math inline">\(M\)</span> of <span class="math inline">\(S\)</span>, if <span class="math inline">\(x \not\in S\)</span> and <span class="math inline">\(\mathbf{B}_2(M,x)=1\)</span>, we say that <span class="math inline">\(x\)</span> is a <em>false positive</em>. And we say that the probability bound <span class="math inline">\(\varepsilon\)</span> of outputting false positives is the <em>error rate</em> of <span class="math inline">\(\mathbf{B}\)</span>.</p>
<p>In an adversarial environment, consider the following experiment for any Bloom filter <span class="math inline">\(\mathbf{B}=(\mathbf{B}_1,\mathbf{B}_2)\)</span>, adversary <span class="math inline">\(\mathcal{A}\)</span>, value <span class="math inline">\(t\)</span> as the bound of the amount of queries which <span class="math inline">\(\mathcal{A}\)</span> can make, and value <span class="math inline">\(\lambda\)</span> as the security parameter.</p>
<p><strong>The Bloom filter resilience challenge experiment <span class="math inline">\(\mathsf{Challenge}_{\mathcal{A},\mathbf{B},t}(\lambda)\)</span>:</strong></p>
<ol type="1">
<li><span class="math inline">\(M \leftarrow \mathbf{B}_1(1^\lambda,S)\)</span>.<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a></li>
<li><span class="math inline">\(x^* \leftarrow \mathcal{A}^{\mathbf{B}_2(M,\cdot)}(1^\lambda,S)\)</span>, where <span class="math inline">\(\mathcal{A}\)</span> performs at most <span class="math inline">\(t\)</span> queries <span class="math inline">\(x_1,\dots,x_t\)</span> to the oracle <span class="math inline">\(\mathbf{B}_2(M,\cdot)\)</span>. Note that <span class="math inline">\(\mathcal{A}\)</span> has only oracle access to the Bloom filter and cannot see the representation <span class="math inline">\(M\)</span>.<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a></li>
<li>The output of the experiment is defined to be <span class="math inline">\(1\)</span>, if <span class="math inline">\(x^* \not\in S \cup \{x_1,\dots,x_t\}\)</span> and <span class="math inline">\(\mathbf{B}_2(M,x^*)=1\)</span>, and <span class="math inline">\(0\)</span> otherwise. If the output of the experiment is <span class="math inline">\(1\)</span>, we say that <span class="math inline">\(\mathcal{A}\)</span> succeeds.</li>
</ol>
<p><strong>Definition 2. (Adversarial-resilient Bloom filter)</strong> <em>Let <span class="math inline">\(\mathbf{B}=(\mathbf{B}_1,\mathbf{B}_2)\)</span> be an <span class="math inline">\((n,\varepsilon)\)</span>-Bloom filter (with a steady representation). We say that <span class="math inline">\(\mathbf{B}\)</span> is an <span class="math inline">\((n,t,\varepsilon)\)</span>-adversarial resilient Bloom filter if for any set <span class="math inline">\(S\)</span> of size <span class="math inline">\(n\)</span>, for all sufficiently large <span class="math inline">\(\lambda \in \mathbb{N}\)</span> and for all probabilistic polynomial-time adversaries <span class="math inline">\(\mathcal{A}\)</span>, it holds that</em> <span class="math display">\[\Pr[\mathsf{Challenge}_{\mathcal{A},\mathbf{B},t}(\lambda) = 1] \leq \varepsilon\]</span></p>
<p><em>where the probability is taken over the randomness used by the algorithm <span class="math inline">\(\mathbf{B}_1\)</span> and <span class="math inline">\(\mathcal{A}\)</span>.</em></p>
<p>To define the non-triviality of a Bloom filter formally, notice that it is always desirable to minimize the memory use of the Bloom filter. Let <span class="math inline">\(\mathbf{B}\)</span> be an <span class="math inline">\((n,\varepsilon)\)</span>-Bloom filter that uses <span class="math inline">\(m\)</span> bits of memory. It is shown<span class="citation" data-cites="carter1978exact">[3]</span> that the lower bound of <span class="math inline">\(m\)</span> is <span class="math inline">\(m \geq n \log \frac{1}{\varepsilon}\)</span>. Thus, we define</p>
<p><strong>Definition 3. (Minimal error)</strong> <em>Let <span class="math inline">\(\mathbf{B}\)</span> be an <span class="math inline">\((n,\varepsilon)\)</span>-Bloom filter. We say that <span class="math inline">\(\varepsilon_0 = 2^{-\frac{m}{n}}\)</span> is the minimal error of <span class="math inline">\(\mathbf{B}\)</span>.</em></p>
<p>As mentioned previously, a trivial construction of Bloom filters is a lookup table that stores <span class="math inline">\(S\)</span> precisely, in which case, the memory use <span class="math inline">\(m=\log \binom{u}{n} \approx n \log(\frac{u}{n})\)</span>, thus by using the bound <span class="math inline">\(m \geq n \log \frac{1}{\varepsilon}\)</span>, a construction is trivial if <span class="math inline">\(\varepsilon &gt; \frac{n}{u}\)</span>. On the other hand, if <span class="math inline">\(u\)</span> is super-polynomial in <span class="math inline">\(n\)</span>, then <span class="math inline">\(\varepsilon\)</span> is negligible in <span class="math inline">\(n\)</span> and every polynomial-time adversary has only negligible probability to find any false positive, therefore for such <span class="math inline">\(S \subset U\)</span>, the Bloom filter must be trivial. Notice that <span class="math inline">\(\varepsilon_o \leq \varepsilon\)</span>, we then define</p>
<p><strong>Definition 4. (Non-trivial Bloom filter)</strong> <em>Let <span class="math inline">\(\mathbf{B}\)</span> be an <span class="math inline">\((n,\varepsilon)\)</span>-Bloom filter and let <span class="math inline">\(\varepsilon_0\)</span> be the minimal error of <span class="math inline">\(\mathbf{B}\)</span>. We say that <span class="math inline">\(\mathbf{B}\)</span> is non-trivial if there exists a constant <span class="math inline">\(c \geq 1\)</span> such that <span class="math inline">\(\varepsilon_0 &gt; \max\{\frac{n}{u},\frac{1}{n^c}\}\)</span>.</em></p>
</section>
<section id="resilient-bloom-filters-and-one-way-functions" class="level1">
<h1>3. Resilient Bloom Filters and One-Way Functions</h1>
<p>We now show that the existence of adversarial resilient Bloom filters depends on the existence of one-way functions, that is, if any non-trivial, strongly resilient Bloom filter exists, then one-way functions also exist.</p>
<p><strong>Theorem 5.</strong> <em>Let <span class="math inline">\(\mathbf{B}=(\mathbf{B}_1,\mathbf{B}_2)\)</span> be any non-trivial Bloom filter (with a steady representation) of <span class="math inline">\(n\)</span> elements that uses <span class="math inline">\(m\)</span> bits of memory, and let <span class="math inline">\(\varepsilon_0\)</span> be the minimal error of <span class="math inline">\(\mathbf{B}\)</span>. If <span class="math inline">\(\mathbf{B}\)</span> is <span class="math inline">\((n,t,\varepsilon)\)</span>-adversarial resilient for <span class="math inline">\(t=\mathcal{O}(\frac{m}{\varepsilon_0^2})\)</span>, then one-way functions exist.</em></p>
<p><strong>Proof.</strong> First we assume that one-way functions do not exist, then we show that we can construct a polynomial-time adversary <span class="math inline">\(\mathcal{A}\)</span> such that <span class="math display">\[\Pr[\mathsf{Challenge}_{\mathcal{A},\mathbf{B},t}(\lambda) = 1] &gt; \varepsilon\]</span> given a fixed value <span class="math inline">\(\varepsilon\)</span>. That is, <span class="math inline">\(\mathbf{B}\)</span> cannot be <span class="math inline">\((n,t,\varepsilon)\)</span>-adversarial resilient.</p>
<p>Define the following function <span class="math inline">\(f\)</span>: <span class="math display">\[f(S,r,x_1,\dots,x_t) = (x_1,\dots,x_t,\mathbf{B}_2(M,x_1),\dots,\mathbf{B}_2(M,x_t))\]</span> where <span class="math inline">\(S\)</span> is a set of size <span class="math inline">\(n\)</span>, <span class="math inline">\(r\)</span> is the number of bits used by the randomness of <span class="math inline">\(\mathbf{B}_1\)</span>, <span class="math inline">\(M\)</span> is a representation of <span class="math inline">\(S\)</span> generated by <span class="math inline">\(\mathbf{B}_1\)</span>, and <span class="math inline">\(t=\frac{200m}{\varepsilon_0}\)</span>. Clearly, <span class="math inline">\(f\)</span> is polynomial-time computable.</p>
<p>Since <span class="math inline">\(f\)</span> is not a one-way function (under the assumption that one-way functions do not exist), there is also an algorithm that can invert <span class="math inline">\(f\)</span> efficiently. Thus we have,</p>
<p><strong>Claim 6.</strong> <em>Assume that one-way functions do not exist, there exists a polynomial-time algorithm <span class="math inline">\(\mathcal{A}\)</span> that inverts <span class="math inline">\(f\)</span> with a failure probability of at most <span class="math inline">\(\frac{1}{100}\)</span>:</em> <span class="math display">\[\Pr[f(\mathcal{A}(f(S,r,x_1,\dots,x_t))) \neq f(S,r,x_1,\dots,x_t)] &lt; \frac{1}{100}\]</span></p>
<p><strong>Proof.</strong> Because <span class="math inline">\(f\)</span> is not a one-way function, there exists<span class="citation" data-cites="katz2014introduction">[4]</span> an algorithm <span class="math inline">\(\mathcal{A}&#39;\)</span> such that <span class="math inline">\(\Pr[\mathsf{Invert}_{\mathcal{A}&#39;,f}(n) = 1] \geq \frac{1}{p(n)}\)</span>, where <span class="math inline">\(p(n)\)</span> is polynomial in <span class="math inline">\(n\)</span>. Construct an algorithm <span class="math inline">\(\mathcal{A}\)</span> that runs <span class="math inline">\(\mathcal{A}&#39;\)</span> individually for <span class="math inline">\(\lceil\frac{\log 100}{\log(p(n)) - \log(p(n)-1)}\rceil\)</span> times, so we have the total failure probability <span class="math inline">\(\Pr[f(\mathcal{A}(f(S,r,x_1,\dots,x_t))) \neq f(S,r,x_1,\dots,x_t)] &lt; \left(1-\frac{1}{p(n)}\right)^{\lceil\frac{\log 100}{\log(p(n)) - \log(p(n)-1)}\rceil} \leq \frac{1}{100}\)</span> <p style='text-align:right !important;text-indent:0 !important;position:relative;top:-1em'>&#9632;</p></p>
<p>Using <span class="math inline">\(\mathcal{A}\)</span>, construct the following probabilistic polynomial-time algorithm <span class="math inline">\(\mathsf{Attack}\)</span>:</p>
<blockquote style="background:gainsboro; border-radius:1em; padding:.25em .5em;">
<p><strong>The Algorithm <span class="math inline">\(\mathsf{Attack}\)</span></strong></p>
<p><span class="math inline">\(\mathsf{Attack}\)</span> is given oracle access to the query algorithm <span class="math inline">\(\mathbf{B}_2(M,\cdot)\)</span>, and gets <span class="math inline">\(1^\lambda\)</span> as input.</p>
<ol type="1">
<li>For <span class="math inline">\(i \in \{1,\dots,t\}\)</span>, sample <span class="math inline">\(x_i \in U\)</span> uniformly, and query <span class="math inline">\(y_i = \mathbf{B}_2(M,x_i)\)</span>.</li>
<li>Run <span class="math inline">\(\mathcal{A}\)</span> (the inverter of <span class="math inline">\(f\)</span>) and get <span class="math inline">\((S&#39;,r&#39;,x_1,\dots,x_t) \leftarrow \mathcal{A}(x_1,\dots,x_t,y_1,\dots,y_t)\)</span>.</li>
<li>Compute <span class="math inline">\(M&#39; \overset{r&#39;}{\leftarrow} \mathbf{B}_1(1^\lambda,S&#39;)\)</span>, using <span class="math inline">\(r&#39;\)</span> as the randomness bits in the initialization.</li>
<li>For <span class="math inline">\(k=1,\dots,\frac{100}{\varepsilon_0}\)</span>, do:
<ol type="a">
<li>Sample <span class="math inline">\(x^* \in U\)</span> uniformly.</li>
<li>If <span class="math inline">\(\mathbf{B}_2(M&#39;,x^*)=1\)</span> and <span class="math inline">\(x^* \not\in \{x_1,\dots,x_t\}\)</span>, output <span class="math inline">\(x^*\)</span> and HALT.</li>
</ol></li>
<li>Sample <span class="math inline">\(x^* \in U\)</span> uniformly, and output <span class="math inline">\(x^*\)</span>.</li>
</ol>
</blockquote>
<p><strong>Claim 7.</strong> <em>Assume that <span class="math inline">\(\mathcal{A}\)</span> inverts <span class="math inline">\(f\)</span> successfully. For any representation <span class="math inline">\(M\)</span>, the probability such that there exists a representation <span class="math inline">\(M&#39;\)</span> that for <span class="math inline">\(i \in \{1,\dots,t\}\)</span>, <span class="math inline">\(\mathbf{B}_2(M,x_i)=\mathbf{B}_2(M&#39;,x_i)\)</span>, and that the error rate <span class="math inline">\(\Pr[\mathbf{B}_2(M,x) \neq \mathbf{B}_2(M&#39;,x)] &gt; \frac{\varepsilon_0}{100}\)</span> is at most <span class="math inline">\(\frac{1}{100}\)</span>.</em></p>
<p><strong>Proof.</strong> From the error rate of any <span class="math inline">\(x\)</span> and the independence of the choice of <span class="math inline">\(x_i\)</span>, we get <span class="math display">\[\Pr[\forall i \in \{1,\dots,t\} : \mathbf{B}_2(M,x_i) = \mathbf{B}_2(M&#39;,x_i)] \leq \left(1 - \frac{\varepsilon_0}{100}\right)^t\]</span></p>
<p>Since the Bloom filter uses <span class="math inline">\(m\)</span> bits of memory, there are <span class="math inline">\(2^m\)</span> possible representations as candidates for <span class="math inline">\(M&#39;\)</span>. Thus, by union bound, <span class="math display">\[\Pr[\exists M&#39; \ \forall i \in \{1,\dots,t\} : \mathbf{B}_2(M,x_i) = \mathbf{B}_2(M&#39;,x_i)] \leq 2^m \left(1 - \frac{\varepsilon_0}{100}\right)^t \leq \frac{1}{100}\]</span></p>
<p>Since <span class="math inline">\(\mathcal{A}\)</span> is assumed to invert <span class="math inline">\(f\)</span> successfully, it must output a representation <span class="math inline">\(M&#39;\)</span> such that for <span class="math inline">\(i \in \{1,\dots,t\}\)</span>, <span class="math inline">\(\mathbf{B}_2(M,x_i)=\mathbf{B}_2(M&#39;,x_i)\)</span>. Therefore, the above bound holds. <p style='text-align:right !important;text-indent:0 !important;position:relative;top:-1em'>&#9632;</p></p>
<p>Define <span class="math inline">\(\mu(M)=\Pr_{x \in U}[\mathbf{B}_2(M,x)=1]\)</span> as the positive rate over <span class="math inline">\(U\)</span>, we now show that for almost all possible representations <span class="math inline">\(M\)</span> generated from set <span class="math inline">\(S\)</span> and randomness <span class="math inline">\(r\)</span>, it holds true that <span class="math inline">\(\mu(M) &gt; \frac{\varepsilon_0}{8}\)</span>, with only a negligible probability of error:</p>
<p><strong>Claim 8.</strong> <span class="math inline">\(\Pr_S[\exists r : \mu(M_r^S) \leq \frac{\varepsilon}{8}] \leq 2^{-n}\)</span>.</p>
<p><strong>Proof.</strong> Let <span class="math inline">\(\mathsf{BAD}\)</span> be the set of all sets <span class="math inline">\(S\)</span> such that there exists an <span class="math inline">\(r\)</span> such that <span class="math inline">\(\mu(M_r^S) \leq \frac{\varepsilon_0}{8}\)</span>. Given <span class="math inline">\(S \in \mathsf{BAD}\)</span>, let <span class="math inline">\(\hat{S}\)</span> be the set of all elements <span class="math inline">\(x\)</span> such that <span class="math inline">\(\mathbf{B}_2(M_r^S,x)=1\)</span>, then <span class="math inline">\(|\hat{S}| \leq \frac{\varepsilon_0}{8} \cdot u\)</span>. Notice that we can encode the set <span class="math inline">\(S\)</span> using the representation <span class="math inline">\(M_r^S\)</span> while specifying <span class="math inline">\(S\)</span> from all subsets of <span class="math inline">\(\hat{S}\)</span> of size <span class="math inline">\(n\)</span>, and the encoding bits must be no less than <span class="math inline">\(\log|\mathsf{BAD}|\)</span> (which is the number of bits required to encode <span class="math inline">\(|\mathsf{BAD}|\)</span>): <span class="math display">\[\log|\mathsf{BAD}| \leq m + \log\binom{\frac{\varepsilon_0 u}{8}}{n}
\leq m + n \log\left(\frac{\varepsilon_0 u}{8}\right) - n \log n + 2n
\leq -n + \log\binom{u}{n}
\]</span> thus <span class="math inline">\(|\mathsf{BAD}| \leq 2^{-n}\binom{u}{n}\)</span>. Since the number of sets <span class="math inline">\(S\)</span> is <span class="math inline">\(\binom{u}{n}\)</span>, <span class="math inline">\(\Pr_S[\exists r : \mu(M_r^S) \leq \frac{\varepsilon}{8}] \leq 2^{-n}\)</span>. <p style='text-align:right !important;text-indent:0 !important;position:relative;top:-1em'>&#9632;</p></p>
<p><strong>Claim 9.</strong> <em>Assume that <span class="math inline">\(\Pr[\mathbf{B}_2(M,x) \neq \mathbf{B}_2(M&#39;,x)] \leq \frac{\varepsilon_0}{100}\)</span> and that <span class="math inline">\(\mu(M) &gt; \frac{\varepsilon_0}{8}\)</span>. The probability that <span class="math inline">\(\mathsf{Attack}\)</span> does not halt on Step 4 is at most <span class="math inline">\(\frac{1}{100}\)</span>.</em></p>
<p><strong>Proof.</strong> It follows directly from the assumptions that <span class="math inline">\(\mu(M&#39;) &gt; \frac{\varepsilon_0}{8} - \frac{\varepsilon_0}{100} &gt; \frac{\varepsilon_0}{10}\)</span>. For convenience, let <span class="math inline">\(\mathcal{X} = \{x_1,\dots,x_t\}\)</span> and <span class="math inline">\(\hat{S&#39;} = \{x : \mathbf{B}_2(M&#39;,x)=1\}\)</span>. We have that</p>
<p><span class="math display">\[E[|\hat{S&#39;} \cap \mathcal{X}|] = t \cdot \mu(M&#39;) &gt; \frac{200m}{\varepsilon_0} \cdot \frac{\varepsilon_0}{10} = 20m\]</span></p>
<p>By Chernoff bound with a probability of at least <span class="math inline">\((1-e^{-\Omega(m)})\)</span> we have that <span class="math inline">\(|\hat{S&#39;} \cap \mathcal{X}| &lt; 40m\)</span>, <span class="math display">\[|\hat{S&#39;} \backslash \mathcal{X}|=|\hat{S&#39;}|-|\hat{S&#39;} \cap \mathcal{X}| &gt; |\hat{S&#39;}| - 40m \geq \frac{\varepsilon_0 u}{10} - 40m\]</span></p>
<p><em>Case 1.</em> <span class="math inline">\(u=n^d\)</span> (<span class="math inline">\(d\)</span> is a constant). We show that <span class="math inline">\(|\hat{S&#39;} \backslash \mathcal{X}| \geq 1\)</span>, so that an exhaustive search over the universal set <span class="math inline">\(U\)</span> is efficient and guaranteed to find an element <span class="math inline">\(x^*\)</span> in <span class="math inline">\(\hat{S&#39;} \backslash \mathcal{X}\)</span>. Let <span class="math inline">\(c\)</span> be a constant such that <span class="math inline">\(\varepsilon_0 &gt; \frac{1}{n^c}\)</span>, <span class="math inline">\(\varepsilon_0 &lt; \frac{1}{n^{c-1}}\)</span>. We have <span class="math inline">\(\frac{u}{n} = n^{d-1} \geq \frac{1}{\varepsilon_0} &gt; n^{c-1}\)</span>, then <span class="math inline">\(d-c&gt;1\)</span>. Moreover, <span class="math inline">\(m \leq n \log\frac{u}{n} \leq nd \log n\)</span>, thus, <span class="math display">\[|\hat{S&#39;} \backslash \mathcal{X}| \geq \frac{\varepsilon_0 u}{10} - 40m
\geq \frac{n^{d-c}}{10} - 40nd \log n &gt; 1\]</span></p>
<p><em>Case 2.</em> <span class="math inline">\(u\)</span> is super-polynomial in <span class="math inline">\(n\)</span>. We show that the fraction of <span class="math inline">\(|\hat{S&#39;} \backslash \mathcal{X}|\)</span> is large enough so that sampling can find an <span class="math inline">\(x^*\)</span>, with only a small failure probability. Since <span class="math inline">\(\frac{\varepsilon_0}{20}\)</span> is polynomial in <span class="math inline">\(\frac{1}{n}\)</span> but <span class="math inline">\(\frac{40m}{u} \leq \frac{40n \log u}{u}\)</span> is negligible, we get that <span class="math inline">\(\frac{\varepsilon_0}{20} &gt; \frac{40m}{u}\)</span>. It follow from <span class="math inline">\(\frac{|\hat{S&#39;} \backslash \mathcal{X}|}{u} &gt; \frac{\varepsilon_0}{10} - \frac{40m}{u}\)</span> that <span class="math inline">\(\frac{|\hat{S&#39;} \backslash \mathcal{X}|}{u} &gt; \frac{\varepsilon_0}{20}\)</span>. Thus, the probability of sampling <span class="math inline">\(x \not\in \hat{S&#39;} \backslash \mathcal{X}\)</span> in all <span class="math inline">\(k\)</span> attempts is bounded by <span class="math display">\[\left(1-\frac{\varepsilon_0}{20}\right)^k
= \left(1-\frac{\varepsilon_0}{20}\right)^\frac{100}{\varepsilon_0}
&lt; \frac{1}{100}
\]</span></p>
<p>In both cases, the probability that <span class="math inline">\(\mathsf{Attack}\)</span> fails to find <span class="math inline">\(x^*\)</span> and halt on Step 4 is less than <span class="math inline">\(\frac{1}{100}\)</span>. <p style='text-align:right !important;text-indent:0 !important;position:relative;top:-1em'>&#9632;</p></p>
<p><strong>Claim 10.</strong> <span class="math inline">\(\Pr[\mathbf{B}(M&#39;,x^*)=1; \mathbf{B}_2(M,x^*)=0] \leq \frac{1}{100}\)</span></p>
<p><strong>Proof.</strong> This follows from the assumption that <span class="math inline">\(\Pr[\mathbf{B}_2(M,x) \neq \mathbf{B}_2(M&#39;,x)] \leq \frac{\varepsilon}{100}\)</span>. <p style='text-align:right !important;text-indent:0 !important;position:relative;top:-1em'>&#9632;</p></p>
<p>Consider <strong>Claim 6, 7, 8 &amp; 10</strong> which cover all cases that <span class="math inline">\(\mathsf{Attack}\)</span> fails, each happens only if the respective assumptions hold, so they provide an upper bound of failure probability. Taking a union bound, we have the total failure probability is at most <span class="math inline">\(\frac{4}{100}\)</span>. Thus, we have constructed a polynomial-time adversary <span class="math inline">\(\mathsf{Attack}\)</span> such that <span class="math display">\[\Pr[\mathsf{Challenge}_{\mathsf{Attack},\mathbf{B},t}(\lambda) = 1] &gt; \varepsilon \geq 1-\frac{4}{100}\]</span> therefore <span class="math inline">\(\mathbf{B}\)</span> cannot be <span class="math inline">\((n,t,\varepsilon)\)</span>-adversarial resilient, which is a contradiction implying that such adversarial resilient Bloom filters do not exist, under the assumption that one-way functions do not exist. By modus tollens, we have that if non-trivial <span class="math inline">\((n,t,\varepsilon)\)</span>-adversarial resilient Bloom filters exist, then one-way functions exist. <p style='text-align:right !important;text-indent:0 !important;position:relative;top:-1em'>&#9632;</p></p>
</section>
<section id="further-reading" class="level1">
<h1>4. Further Reading</h1>
<p>In <strong>Theorem 5</strong> we showed that the existence of adversarial resilient Bloom filters implies that one-way functions exist. Furthermore, assume that adversarial resilient Bloom filters exist (thus one-way functions exist), it can be shown that pseudorandom permutations may be used to construct non-trivial, strongly adversarial resilient Bloom filters. We have</p>
<p><strong>Proposition 11. (Construction using pseudorandom permutations)</strong><a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> <em>Let <span class="math inline">\(\mathbf{B}\)</span> be an <span class="math inline">\((n,\varepsilon)\)</span>-Bloom filter using <span class="math inline">\(m\)</span> bits of memory. If pseudorandom permutations exist, then for any security parameter <span class="math inline">\(\lambda\)</span>, there exists an <span class="math inline">\((n,\varepsilon+\mathsf{negl}(\lambda))\)</span>-strongly resilient Bloom filter that uses <span class="math inline">\(m&#39;=m+\lambda\)</span> bits of memory.</em></p>
<p><strong>Unsteady representation and computationally unbounded adversary.</strong> The above discussion about Bloom filters assumes that steady representation is used, that is, the query algorithm <span class="math inline">\(\mathbf{B}_2\)</span> is deterministic. Some implementations allow <span class="math inline">\(\mathbf{B}_2\)</span> to change the internal representation thus querying can also be probabilistic. Further results regarding <em>unsteady representations</em> may be found in <span class="citation" data-cites="naor2015bloom">[5]</span>, with the ACD<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a> framework proposed in <span class="citation" data-cites="naor2006learning">[6]</span>. Moreover, some results are shown to hold even for <em>computationally unbounded adversaries</em>.</p>
<p><strong>Bloom filters and secrecy.</strong> Bloom filters, like hash functions, are not designed as encryption schemes. Thus, even adversarial resilient Bloom filters may leak considerable information in an unintended way. As a concrete example, in Bitcoin lightweight SPV clients which rely on Bloom filters to store users’ Bitcoin addresses, an adversary can efficiently distinguish information about these addresses. See <span class="citation" data-cites="gervais2014privacy">[7]</span> for a discussion on this interesting scenario.</p>
</section>
<section id="references" class="level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-maggs2015algorithmic">
<p>[1] B. M. Maggs and R. K. Sitaraman, “Algorithmic nuggets in content delivery,” <em>ACM SIGCOMM Computer Communication Review</em>, vol. 45, no. 3, pp. 52–66, 2015. </p>
</div>
<div id="ref-benjaminattacks">
<p>[2] R. Benjamin and E. K. Yasmine, “Attacks on bitcoin,” 2015. </p>
</div>
<div id="ref-carter1978exact">
<p>[3] L. Carter, R. Floyd, J. Gill, G. Markowsky, and M. Wegman, “Exact and approximate membership testers,” in <em>Proceedings of the tenth annual acm symposium on theory of computing</em>, 1978, pp. 59–65. </p>
</div>
<div id="ref-katz2014introduction">
<p>[4] J. Katz and Y. Lindell, “Introduction to modern cryptography,” 2014. </p>
</div>
<div id="ref-naor2015bloom">
<p>[5] M. Naor and E. Yogev, “Bloom filters in adversarial environments,” in <em>Annual cryptology conference</em>, 2015, pp. 565–584. </p>
</div>
<div id="ref-naor2006learning">
<p>[6] M. Naor and G. N. Rothblum, “Learning to impersonate,” in <em>Proceedings of the 23rd international conference on machine learning</em>, 2006, pp. 649–656. </p>
</div>
<div id="ref-gervais2014privacy">
<p>[7] A. Gervais, S. Capkun, G. O. Karame, and D. Gruber, “On the privacy provisions of bloom filters in lightweight bitcoin clients,” in <em>Proceedings of the 30th annual computer security applications conference</em>, 2014, pp. 326–335. </p>
</div>
</div>
</section>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>We will only consider polynomial-time adversaries here.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>For this reason, a <em>yes</em>-answer is also referred to as a <em>maybe</em>-answer in some texts.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>A CDN (Content Delivery Network) is a globally distributed network of proxy servers deployed in multiple data centers, in order to serve cached content to end-users with high availability and high performance.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>In this work, we will consider only steady representations.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>The security parameter <span class="math inline">\(\lambda\)</span> is implied in the initialization algorithm <span class="math inline">\(\mathbf{B}_1\)</span>, thus we denote it as <span class="math inline">\(\mathbf{B}_1(1^\lambda,S)\)</span>.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>To strengthen our definition, we assume that the adversary also gets the set <span class="math inline">\(S\)</span>, and it is important that the adversary can hardly find any false positive even if given <span class="math inline">\(S\)</span>.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>A proof of this can be found in <span class="citation" data-cites="naor2015bloom">[5]</span>.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>Learning model of adaptively changing distributions (ACD).<a href="#fnref8">↩</a></p></li>
</ol>
</section>
      </div>
      <!-- (www.soimort.org) last updated: 2016-05-07 -->
      <aside id="soimort-toolbar">
        <a href="/"><i class="fa fa-home" aria-hidden="true"></i></a>
      </aside>
    </article>
  </body>
</html>
